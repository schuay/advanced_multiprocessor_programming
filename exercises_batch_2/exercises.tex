\documentclass[a4paper,10pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[usenames,dvipsnames]{color}
\usepackage{comment}
\usepackage[utf8]{inputenc}
\usepackage{listings}

\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{Gray}{gray}{0.5}

\lstset{
    language=Java,
    basicstyle=\ttfamily,
    keywordstyle=\color{OliveGreen},
    commentstyle=\color{Gray},
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showspaces=false,
    showtabs=false,
    numbers=left,
}

\newcommand{\Sp}{$s^{'}$}
\newcommand{\Spp}{$s^{''}$}

\title{VU Advanced Multiprocessor Programming \\
       SS 2013 \\
       Exercises Batch 2}
\author{Jakob Gruber, 0203440}

\begin{document}

\maketitle

\tableofcontents

\pagebreak

\section{Specifications}

Select any 10 of $\{21, 22, 23, 24, 27, 32, 51, 52, 53, 54, 58, 62, 65, 68\}$ 
from \emph{Maurice Herlihy, Nir Shavit: The Art of Multiprocessor Programming. 
Morgan Kaufmann, 2008. Revised 1st Edition, 2012.}

\section{Solutions}

\subsection{Exercise 53}

\emph{The \lstinline|Stack| class provides two methods: \lstinline|push(x)| pushes a value onto the top of the stack, and \lstinline|pop()| removes and returns the most recently pushed value. Prove that the \lstinline|Stack| class has consensus number exactly two.}

\vspace{3mm}

\emph{Consensus object}: provides a method \lstinline|T decide(T value)| which is called by each thread at most once. It is \emph{consistent} (all threads decide the same value) and \emph{valid} (the common decision value is some thread's input).

\emph{Consensus protocol}: a solution to the consensus problem that is wait-free (and therefore also lock-free).

\emph{Consensus number}: A class C solves n-thread consensus if there exists a consensus protocol using any number of objects of class C and any number of atomic registers. The consensus number is the largest n for which class C solves n-thread consensus.

This proof is similar to the FIFO Queue proof in the book, pages 108 to 110. To show that the consensus number of \lstinline|Stack| is at least two, we construct a consensus protocol as in Figure \ref{fig:stackconsensus}.

\begin{figure}
\begin{lstlisting}
class StackConsensus<T> {
    Stack s;
    T[] proposed;
    StackConsensus() {
        s.push(LOSE);
        s.push(WIN);
    }
    T decide(T value) {
        proposed[threadID] = value;
        if (s.pop() == WIN) {
            return proposed[threadID];
        } else {
            return proposed[1 - threadID];
        }
    }
}
\end{lstlisting}
\caption{A stack consensus protocol.}
\label{fig:stackconsensus}
\end{figure}

This protocol is wait-free since \lstinline|Stack| is wait-free and \lstinline|decide()| contains no loops. If each thread returns its own input, both must have popped \lstinline|WIN|, violating the \lstinline|Stack| protocol. Likewise, both threads returning the other's value also violates the protocol. Additionally, the protocol must return one of the proposed values because the winning value is written before \lstinline|WIN| is popped.

We now need to show that \lstinline|Stack| has a consensus number of exactly two. Assume we have a consensus protocol for threads A, B, and C. According to Lemma 5.1.3, there must be a critical state s. Without loss of generality, we assume that A's next move takes to protocol to a 0-valent state, and B's next move leads to a 1-valent state. We also know that these calls must be non-communtative; this implies that they need to be calls on the same object. Next, we know that these calls cannot be made to registers since registers have a consensus number of 1. Therefore, these calls must be made to the same stack object. We can now distinguish between three cases: either both A and B call \lstinline|push()|, both call \lstinline|pop()|, or A calls \lstinline|push()| while B calls \lstinline|pop()|.

Suppose both A and B call \lstinline|pop()|. Let \Sp be the state if A pops, followed by B; and \Spp if the pops occur in the opposite order. Since \Sp is 0-valent while \Spp is 1-valent, and C cannot distinguish between both states, it is impossible for C to decide the correct value in both states.

Suppose both A and B call \lstinline|push()|. Let \Sp equal the state after A pushes a, B pushes b, A pops b, and B pops a. Likewise, let \Spp equal the state after B pushes b, A pushes a, A pops a, and B pops b. The pops must occur because it is the only way to observe the state of the stack. Again, states \Sp and \Spp are indistinguishable for C, contradicting the fact that \Sp is 0-valent while \Spp is 1-valent.

Suppose A calls \lstinline|push()| while B calls \lstinline|pop()|. Let \Sp be the state after A pushes a, B pops a, and A pops the uppermost value of the stack (if it exists). Let \Spp be the state after B pops the uppermost value (if it exists), A pushes a, and A pops a. C cannot distinguish between both states. We do not care what happens if an empty stack is popped, since that does not affect the state visible to C.

\vspace{3mm}

\subsection{Exercise 54}

\emph{Suppose we augment the FIFO Queue class with a \lstinline|peek()| method
that returns but does not remove the first element in the queue. Show that the
augmented queue has infinite consensus number.}

\vspace{3mm}

We show this by constructing a decision protocol using a FIFO Queue with an infinite consensus number as shown in Figure \ref{fig:fifoconsensus}.

\begin{figure}
\begin{lstlisting}
class FIFOConsensus<T> {
    FIFO f;
    T[] proposed;
    T decide(T value) {
        proposed[threadID] = value;
        f.enq(threadID);
        return proposed[f.peek()];
    }
}
\end{lstlisting}
\caption{A consensus protocol using FIFO queues.}
\label{fig:fifoconsensus}
\end{figure}

This protocol is wait-free since \lstinline|FIFO| is wait-free, and \lstinline|decide()| contains no loops. If two threads return different values,
\lstinline|peek()| must have returned different thread ids. Since the first element is never removed, this violates the FIFO Queue protocol. Validity is ensured because each thread writes its value into \lstinline|proposed| before pushing its thread id.

\lstinline|FIFOConsensus| is wait-free, consistent, valid, and works for any number of threads, and as such it is a consensus protocol with an infinite consensus number.

\vspace{3mm}

\subsection{Exercise 58}

\emph{Objects of the \lstinline|StickyBit| class have three possible states $\bot$, 0, 1,
initially $\bot$. A call to write(v), where v is 0 or 1, has the following effects:
If the object’s state is $\bot$, then it becomes v.
If the object’s state is 0 or 1, then it is unchanged.
A call to \lstinline|read()| returns the object’s current state.
1. Show that such an object can solve wait-free binary consensus (that is, all
inputs are 0 or 1) for any number of threads.
2. Show that an array of $\log_2 m$ \lstinline|StickyBit| objects with atomic registers can
solve wait-free consensus for any number of threads when there are m possible inputs. (Hint: you need to give each thread one single-writer, multi-reader
atomic register.)}

\vspace{3mm}

1. Figure \ref{fig:binarystickyconsensus} shows a construction of a binary consensus protocol with consensus number $\infty$.

\begin{figure}
\begin{lstlisting}
class StickyBinaryConsensus<T> {
    StickyBit s;
    T decide(T value) {
        s.write(v);
        return s.read();
    }
}
\end{lstlisting}
\caption{The binary consensus protocol composed of a StickyBit object.}
\label{fig:binarystickyconsensus}
\end{figure}

Validity is given because \lstinline|write()| is called before any value is read (after writing, the state of the sticky bit is equal to the first written value). Consensus is given because a sticky bit changes its value only for the first write (and each following read returns that value). Assuming \lstinline|StickyBit| itself is wait-free, then so is our consensus protocol.

2. Figure \ref{fig:stickyconsensus} shows a consensus protocol implementation for any number of threads and any number of possible values.

\begin{figure}
\begin{lstlisting}
class StickyConsensus<T> {
    int l = number of bits in value;
    int t = number of threads;
    StickyBit[] s = new StickyBit[l];
    MRSWRegister[] a_reg = new MRSWRegister[2 * t]; /* Initially 0. */
    T decide(T value) {
        T v = value;
        a_reg[t + threadID] = value;
        a_reg[threadID] = 1;
        for (int i = 0; i < l; i++) {
            b = bit i of v;
            s[i].write(b);
            if (s[i].read() != b) {
                for (int j = 0; j < t; j++) {
                    if (a_reg[j] == 1 && bits [0..i] match in a_reg[t + j] and s) {
                    v = a_reg[t + j];
                }
            }
        }
        return booleanArrayToInt(s);
    }
}
\end{lstlisting}
\caption{The consensus protocol composed of a StickyBit object.}
\label{fig:stickyconsensus}
\end{figure}

\lstinline|decide()| first indicates that the current thread has submitted a value
by setting \lstinline|a_reg[threadID]| to 1 and \lstinline|a_reg[t + threadID]| to the
proposed value. It now attempts to set all sticky bits to \lstinline|v|. If it reaches
a point at which the current sticky bit element is already set to another value,
it looks for a thread which has proposed a value matching the already set sticky bits,
and then tries to help that thread complete the sticky bit assignment. Once all
sticky bits have been assigned, their value is returned.

This protocol is wait-free since \lstinline|StickyBit|, the registers and
\lstinline|booleanArrayToInt()| are wait-free, and because all loops are
bounded. It is consistent because it returns a value derived from the sticky
bit array after having attempted a write to each array element (and by
definition of the sticky bit, its value never changes after being written
once).

It remains to show that \lstinline|StickyConsensus| is valid. Let $value_i[k]$
be the $k$'th bit of the value proposed by thread $i$. Suppose there are two
threads $i, j$ and two indices $k < l$ such that $s[k] = value_i[k]$ and $s[l]
= value_j[l]$ (with $value_i[k] \neq value[j[k]$ and $value_i[l] \neq
value_j[l]$). This implies that thread $j$ must have had a \lstinline|v| with
bits $[0..l -1]$ not matching those of $s$. This however is impossible since
during each outer loop iteration, it is checked whether the bits match; if they
don't, \lstinline|v| is changed to match the value of a thread with matching
bits. Therefore, all threads must return the same value, and the protocol is
therefore valid.


\begin{comment}

Exercise 51: p139

\subsection{Exercise }

\emph{}

\vspace{3mm}

\vspace{3mm}

\begin{align}
S(p) &= \frac{s}{s'} = \frac{2s(p - 1)}{s(p - 1) - 1} \\
     &= \frac{2 \cdot \frac{3}{10} \cdot (p - 1)}{\frac{3}{10} \cdot (p - 1) - 1} 
\end{align}

\begin{figure}
\begin{lstlisting}

\end{lstlisting}
\caption{The Flaky lock used in Exercise 11.}
\label{fig:flaky}
\end{figure}

\end{comment}

\end{document}
